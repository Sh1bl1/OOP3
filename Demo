// Interface Ex1 
internal interface IMyType
{
     // What Can Write Inside The Interface:
     // 1. Signature Of Properties
     // 2. Signature Of Methods [Name, Parameter, Return Type]
    // 3. Default Implmented Methods [Fully Implemented Methods]
    // 2. Signature Of Methods [Name, Parameter, Return Type]
     void MyFunO);
    // 1. Signature Of Properties
      double Salary { set; get; }
    // 3. Default Implmented Methods [Fully Implemented Methods]
   void Print()
      {
      Console WriteLine(value: "Default Implmented Methods [Fully Implemented Methods]");
      }
}

internal class Program
{
   static void Main()
   {

   // Interfaces : Reference Type
   // Code Contract Between The Developer Who Write It And The Developer Who Use It (Implementation]
   //МуТуре MуТуре = new IMyType() ;
   // Note : We Can't Create Object From Any Interfaces
    МуТуре MyТуре = new МуТуре:
    My Type. MyFun();
   } 
}


// Ex 2 
internal class SeriesByTwo : ISeries
{
  public int Current ( get; set; } // 0

  public void Next()
  Current += 2;

  public void Reset()
  Current = 0;
}

internal interface ISeries
  {
    int Current {set ; get; }
    void Next();
    void Reset();
  }
static void Print10Number(SeriesByTwo series)
  {
   for(int i = 0; i < 10; i++)
    {
     Console Write($"(series.Current)");
     series. Next();
    }
   Console. WriteLine;
   series .Reset();
}

// Ex 3 
internal interface IMoveable
 {
   int Speed {get; set;}
   void Forward();
   void Backward();
   void Left();
   void Right ();
 }
internal class Car : IMoveable
 {
   public int Speed ( get; set; }
   public void Backward()
   {
     Console. WriteLine(value: "Car IMoveable Backward");
   }
   public void Forward()
   {
     Console .WriteLine( "Car IMoveable Forward");
   }
   public void Left()
   {
     Console. WriteLine("Car IMoveable Left");
   }
   public void Right()
   {
     Console. WriteLine( "Car IMoveable Right");
   }
}
internal interface IFlyable
 {
  int Speed {get; set; }
  void Forward();
  void Backward();
  void Left();
  void Right ();
 }
internal class Plane : IMoveable , IFlyable
 {
   public int Speed ( get; set; }
   public void IMoveable.Backward()
   {
     Console. WriteLine("Plane IMoveable Backward");
   }
   public void IMoveable.Forward()
   {
     Console .WriteLine( "Plane IMoveable Forward");
   }
   public void IMoveable.Left()
   {
     Console. WriteLine("Plane IMoveable Left");
   }
   public void IMoveable.Right()
   {
     Console. WriteLine( "Plane IMoveable Right");
   }
 public void IFlyable.Backward()
   {
     Console. WriteLine("Plane IFlyable Backward");
   }
   public void IFlyable.Forward()
   {
     Console .WriteLine( "Plane IFlyable Forward");
   }
   public void IFlyable.Left()
   {
     Console. WriteLine("Plane IFlyable Left");
   }
   public void IFlyable.Right()
   {
     Console. WriteLine( "Plane IFlyable Right");
   }
}

// Shallow Copy Vs Deep Copy
int[] Arr01 = { 1, 2, 3 };
int[] Arr02 = { 4, 5 , 6 };
Console WriteLine( $"Arr01: (Arr01.GetHashCode}");
Console. WriteLine( $"Arr02: {Arr02. GetHashCode)}*);
Arr02 = Arr01; // Shallow Copy
// Copy Identity
// (1, 2, 3 ) -→> Has Two Reference Arr01, Arr02
// (4, 5, 6) →> UnReachable Object
Console. WriteLine();
Console WriteLine( $" Arr01: (Arr01. GetHashCode}");
Console. WriteLine( $"Arr02: {Arr02.GetHashCode()}*);
// Identity (Address) + Object State [Data]

Arr02 = (int[]) Arr01. Clone(); // //Deep Copy
// clone Method will Copy The Object State Of The Caller
// Assign The New Object To Arr02. Will Generete NEW Identity

// ICloneable
internal class Employee : ICloneable
{
  public int Id { get; set; }
  public string Name { get; set; }
  public int Age { get; set; }
  public double Salary ( get; set; }
  Public Object Clone()
   {
     return new Employee() { Id = this. Id, Name = this. Name, Age = this. Age, Salary = this.Salary }
   }
    public override string ToString()
   {
    return $"Id: (Id}, Name: (Name), Age: (Age), Salary: {Salary}";}
   }
